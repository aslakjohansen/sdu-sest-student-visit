# Advanced 3

```elixir
Mix.install([
  {:vega_lite, "~> 0.1.10"},
  {:kino_vega_lite, "~> 0.1.13"}
])
```

## Forberedelse

Dette trins opave er:

1. Åben igen `index.livemd` (fra [https://github.com/aslakjohansen/livebook-demos](https://github.com/aslakjohansen/livebook-demos)) i Livebook, og evaluér den sidste celle om nødvendigt.
2. Klik dig igennem følgende demoer:
   1. Generic servers, registries and supervision
   2. Dining Philosophers

## Øvelse

I denne øvelse skal vi lave en model af et bageri. Der er en række bagere, der er en række kasseassistenter og så er der nogle kunder der kommer igen og igen.

Alle tre roller er implementeret som genservere, og de benytter et register hver. Jeg har skrevet koden for bagerne, og for kunderne:

```elixir
{:ok, baker_registry_pid} = Registry.start_link(name: BakerRegistry, keys: :duplicate)
```

```elixir
defmodule Baker do
  use GenServer
  
  # (client) interface
  
  def start(product, name) do
    GenServer.start(__MODULE__, [product: product, name: name])
  end
  
  def order(product) do
    case Registry.lookup(BakerRegistry, product) do
      [] ->
        {:error, "No provider for '#{product}'"}
      workers ->
        {pid, _} = Enum.random(workers)
        GenServer.cast(pid, {:order, self()})
        :ok
    end
  end
  
  # callbacks
  
  @impl true
  def init([product: product, name: _] = state) do
    Registry.register(BakerRegistry, product, _value = nil)
    {:ok, state}
  end
  
  @impl true
  def handle_cast({:order, client}, [product: product, name: name] = state) do
    :timer.sleep(1000) # TODO: random(800,1200)
    GenServer.cast(client, {:cake, product, name})
    {:noreply, state}
  end
end
```

```elixir
{:ok, clerk_registry_pid} = Registry.start_link(name: ClerkRegistry, keys: :duplicate)
```

```elixir
defmodule Clerk do
  
end
```

Det er din opgave at skrive koden for kasseassistenterne:

```elixir
{:ok, customer_registry_pid} = Registry.start_link(name: CustomerRegistry, keys: :duplicate)
```

```elixir
defmodule Customer do
  use GenServer
  
  # (client) interface
  
  def start(product, name) do
    GenServer.start(__MODULE__, [product: product, name: "Customer #{name}"])
  end
  
  # callbacks
  
  @impl true
  def init([product: product, name: _] = state) do
    Baker.order(product)
    {:ok, state}
  end

  @impl true
  def handle_cast({:cake, product, name}, [product: p, name: n] = state) do
    IO.puts("[#{n}] Got #{product} from #{name}: Yum! Lets have one more ...")
    Baker.order(p)
    {:noreply, state}
  end
end
```

Startop af genservers:

```elixir
{:ok, baker_1_pid} = Baker.start("Red Velvet Cheesecake", "John")
{:ok, baker_2_pid} = Baker.start("Red Velvet Cheesecake", "Alberte")
{:ok, baker_3_pid} = Baker.start("Red Velvet Cheesecake", "Sofie")
{:ok, baker_4_pid} = Baker.start("Lemon Pie", "Freja")
{:ok, baker_5_pid} = Baker.start("Lemon Pie", "Birger")
{:ok, baker_6_pid} = Baker.start("Carrot Cake", "Hans")
{:ok, baker_7_pid} = Baker.start("Carrot Cake", "Anders")
{:ok, baker_8_pid} = Baker.start("Carrot Cake", "Signe")
bakers = [baker_1_pid, baker_2_pid, baker_3_pid, baker_4_pid, baker_5_pid, baker_6_pid, baker_7_pid, baker_8_pid]
```

```elixir
# clerks =
#   1..clerk_count
#   |> Enum.map(fn i -> Clerk.start(i) end)
```

```elixir
["Red Velvet Cheesecake", "Lemon Pie", "Carrot Cake"]
|> Enum.map(fn product ->
    1..5
    |> Enum.map(fn name -> Customer.start(product, name) end)
  end)
```

## Næste trin ...

Når du er færdig går du til næste øvelse.
